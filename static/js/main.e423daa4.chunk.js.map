{"version":3,"sources":["containers/Visualizer/Visualizer.module.css","helpers/mergeSort.js","helpers/bubbleSort.js","helpers/selectionSort.js","containers/Visualizer/Visualizer.js","App.js","serviceWorker.js","index.js"],"names":["module","exports","mergeSort","array","animations","originalArray","fakeArray","length","half","Math","floor","firstHalf","slice","secondHalf","i","j","sorted","index","indexOf","push","console","log","bubbleSort","selectionSort","maxValue","maxValueIndex","SPEED","LENGTH","Visualizer","state","generateRandomArray","generateRandomIntFromInterval","setState","document","getElementsByClassName","styles","barValue","style","backgroundColor","min","max","random","handleNew","handleMergeSort","getMergeSortAnimations","handleSelectionSort","bars","barOneIndex","barTwoIndex","changeColor","swap","end","barOneStyle","barTwoStyle","setTimeout","temp","height","handleBubbleSort","this","className","visualizerContainer","map","value","key","onClick","Component","App","React","Boolean","window","location","hostname","match","ReactDOM","render","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.e423daa4.chunk.js","sourcesContent":["// extracted by mini-css-extract-plugin\nmodule.exports = {\"visualizerContainer\":\"Visualizer_visualizerContainer__15Uby\",\"bars\":\"Visualizer_bars__JirSs\",\"barValue\":\"Visualizer_barValue__1YIUa\"};","// export function getMergeSortAnimations(array) {\n//   const animations = [];\n//   if (array.length <= 1) return array;\n//   const auxiliaryArray = array.slice();\n//   mergeSortHelper(array, 0, array.length - 1, auxiliaryArray, animations);\n//   console.log('animations', animations);\n//   return animations;\n// }\n// // let i = 0;\n// function mergeSortHelper(\n//   mainArray,\n//   startIdx,\n//   endIdx,\n//   auxiliaryArray,\n//   animations,\n// ) {\n//   if (startIdx === endIdx) return;\n//   // console.log('i', i);\n//   // console.log('startIndex', startIdx);\n//   // console.log('endIdx', endIdx);\n//   // console.log('auxilaryArray', auxiliaryArray);\n//   // console.log('mainArray', mainArray);\n//   const middleIdx = Math.floor((startIdx + endIdx) / 2);\n//   // i += 1;\n//   mergeSortHelper(auxiliaryArray, startIdx, middleIdx, mainArray, animations);\n//   mergeSortHelper(auxiliaryArray, middleIdx + 1, endIdx, mainArray, animations);\n//   // console.log('=============')\n//   doMerge(mainArray, startIdx, middleIdx, endIdx, auxiliaryArray, animations);\n// }\n\n// function doMerge(\n//   mainArray,\n//   startIdx,\n//   middleIdx,\n//   endIdx,\n//   auxiliaryArray,\n//   animations,\n// ) {\n//   let k = startIdx;\n//   let i = startIdx;\n//   let j = middleIdx + 1;\n//   while (i <= middleIdx && j <= endIdx) {\n//     // These are the values that we're comparing; we push them once\n//     // to change their color.\n//     animations.push([i, j]);\n//     // These are the values that we're comparing; we push them a second\n//     // time to revert their color.\n//     animations.push([i, j]);\n//     if (auxiliaryArray[i] <= auxiliaryArray[j]) {\n//       // We overwrite the value at index k in the original array with the\n//       // value at index i in the auxiliary array.\n//       animations.push([k, auxiliaryArray[i]]);\n//       mainArray[k++] = auxiliaryArray[i++];\n//     } else {\n//       // We overwrite the value at index k in the original array with the\n//       // value at index j in the auxiliary array.\n//       animations.push([k, auxiliaryArray[j]]);\n//       mainArray[k++] = auxiliaryArray[j++];\n//     }\n//   }\n//   while (i <= middleIdx) {\n//     // These are the values that we're comparing; we push them once\n//     // to change their color.\n//     animations.push([i, i]);\n//     // These are the values that we're comparing; we push them a second\n//     // time to revert their color.\n//     animations.push([i, i]);\n//     // We overwrite the value at index k in the original array with the\n//     // value at index i in the auxiliary array.\n//     animations.push([k, auxiliaryArray[i]]);\n//     mainArray[k++] = auxiliaryArray[i++];\n//   }\n//   while (j <= endIdx) {\n//     // These are the values that we're comparing; we push them once\n//     // to change their color.\n//     animations.push([j, j]);\n//     // These are the values that we're comparing; we push them a second\n//     // time to revert their color.\n//     animations.push([j, j]);\n//     // We overwrite the value at index k in the original array with the\n//     // value at index j in the auxiliary array.\n//     animations.push([k, auxiliaryArray[j]]);\n//     mainArray[k++] = auxiliaryArray[j++];\n//   }\n// }\n\nexport function getMergeSortAnimations(array) {\n  const animations = [];\n  const sorted = mergeSort(array, animations);\n  console.log('sorted', sorted);\n  console.log('animations', animations)\n  return animations;\n}\n\n\nconst mergeSort = (array, animations, originalArray, fakeArray) => {\n  if (array.length === 1) return array;\n  const half = Math.floor(array.length / 2);\n  const firstHalf = mergeSort(array.slice(0, half), animations, originalArray, fakeArray);\n  const secondHalf = mergeSort(array.slice(half, array.length), animations, originalArray, fakeArray);\n  let i = 0;\n  let j = 0;\n  const sorted = [];\n  while (i < firstHalf.length && j < secondHalf.length) {\n    // console.log(animations)\n    // animations.push([i, j])\n    if (firstHalf[i] < secondHalf[j]) {\n      const index = originalArray.indexOf(firstHalf[i]);\n      animations.push(index);\n      sorted.push(firstHalf[i]);\n      i += 1;\n    } else {\n      const index = originalArray.indexOf(secondHalf[i]);\n      animations.push(index);\n      sorted.push(secondHalf[j]);\n      j += 1;\n    }\n  }\n\n  if (i === firstHalf.length) {\n    const index = originalArray.indexOf(firstHalf[i]);\n    animations.push(index);\n    sorted.push(...secondHalf.slice(j));\n  } else if (j === secondHalf.length) {\n    const index = originalArray.indexOf(firstHalf[i]);\n    animations.push(index);\n    sorted.push(...firstHalf.slice(i));\n  }\n  console.log(sorted);\n  return sorted;\n}\n\n\n\nconst bubbleSort = (array) => {\n  for (let i = 0; i < array.length; i += 1) {\n    for (let j = 1; j < array.length; j += 1) {\n    }\n  }\n}\n\n\nexport default mergeSort;\nconst array = [9, 8, 7, 2]\nconst animations = [];\n// console.log(mergeSort(array, animations, array, array))\n// console.log(animations);\n","export const bubbleSort = (array, animations) => {\n  for (let i = 0; i < array.length; i += 1) {\n    for (let j = 0; j < array.length - i; j += 1) {\n      if (j + 1 < array.length - i) {\n        animations.push([j, j + 1])\n      }\n      if (array[j] > array[j + 1]) {\n        animations.push([j, j + 1, true]);\n        [array[j], array[j + 1]] = [array[j + 1], array[j]];\n      }\n    }\n    animations.push([array.length - 1 - i, array.length - 1 - i, false, true]);\n  }\n  return animations;\n};\n\n// const array = [90, 80, 70, 20];\n// const animations = [];\n\n// console.log(bubbleSort(array, animations));\n// console.log(animations);","export const selectionSort = (array, animations) => {\n  for (let i = 0; i < array.length; i += 1) {\n    let maxValue = array[0];\n    let maxValueIndex = 0;\n    for (let j = 0; j < array.length - i; j += 1) {\n      // two green pointers\n      animations.push([maxValueIndex, j]);\n      if (array[j] > maxValue) {\n        // change color to red\n        animations.push([maxValueIndex, j, true]);\n        maxValue = array[j];\n        maxValueIndex = j;\n      }\n    }\n    animations.push([maxValueIndex, array.length - 1 - i, true]);\n    animations.push([maxValueIndex, array.length - 1 - i, true, true]);\n    [ array[array.length - 1 - i], array[maxValueIndex] ] = [ array[maxValueIndex], array[array.length - 1 - i] ]\n  }\n  animations.push([0, 0, false, false, true])\n  return animations;\n};\n\nconst array = [90, 80, 10, 30];\nconst animations = [];\n\n// console.log(selectionSort(array, animations));\n// console.log(animations);\n\nconst generateRandomIntFromInterval = (min, max) => {\n  return Math.floor(Math.random() * (max - min + 1) + min);\n};\n\nconst makeArray = (length) => {\n  const array = [];\n  for (let i = 0; i < length; i += 1) {\n    array.push(generateRandomIntFromInterval(10, 200));\n  }\n  return array;\n};\n\nconst checkEqual = (array1, array2) => {\n  if (array1.length !== array2.length) return false;\n  for (let i = 0; i < array1.length; i += 1) {\n    if (array1[i] !== array2[i]) return false;\n  }\n  return true;\n};\n\nconst test = (times) => {\n  for (let i = 0; i < times; i += 1) {\n    const array = makeArray(100);\n    const sortedArray = array.slice().sort((a, b) => a - b);\n    const selectedArray = selectionSort(array.slice(), []);\n    const areEqual = checkEqual(sortedArray, selectedArray);\n    if (!areEqual) {\n      return false;\n    }\n  }\n  return true;\n}\n\n// console.log(test(10));\n// console.log(makeArray(10));","import React, { Component } from 'react';\n\nimport { getMergeSortAnimations } from '../../helpers/mergeSort';\nimport { bubbleSort } from '../../helpers/bubbleSort';\nimport { selectionSort } from '../../helpers/selectionSort';\nimport styles from './Visualizer.module.css';\n\nconst SPEED = 1;\nconst LENGTH = 100;\n\nclass Visualizer extends Component {\n  state = {\n    array: [],\n  }\n\n  componentDidMount() {\n    this.generateRandomArray(LENGTH);\n  }\n\n  generateRandomArray = (length) => {\n    const array = [];\n    for (let i = 0; i < length; i += 1) {\n      array.push(this.generateRandomIntFromInterval(10, 150));\n    }\n    this.setState({\n      array,\n    }, () => {\n      for (let i = 0; i < array.length; i += 1) {\n        const bar = document.getElementsByClassName(styles.barValue);\n        bar[i].style.backgroundColor = 'white';\n      }\n    });\n  }\n\n  generateRandomIntFromInterval = (min, max) => {\n    return Math.floor(Math.random() * (max - min + 1) + min);\n  }\n\n  handleNew = () => {\n    this.generateRandomArray(LENGTH);\n  }\n\n  handleMergeSort = () => {\n    const animations = getMergeSortAnimations(this.state.array);\n    // console.log(animations);\n    // for (let i = 0; i < animations.length; i += 1) {\n    //   const bars = document.getElementsByClassName(styles.barValue);\n    //   const isColorChange = i % 3 !== 2;\n    //   if (isColorChange) {\n    //     const [barOneIdx, barTwoIdx] = animations[i];\n    //     const barOneStyle = bars[barOneIdx].style;\n    //     const barTwoStyle = bars[barTwoIdx].style;\n    //     const color = i % 3 === 0 ? 'yellow' : 'red';\n    //     setTimeout(() => {\n    //       barOneStyle.backgroundColor = color;\n    //       barTwoStyle.backgroundColor = color;\n    //     }, i * 1000);\n    //   } else {\n    //     setTimeout(() => {\n    //       const [barOneIdx, newHeight] = animations[i];\n    //       const barOneStyle = bars[barOneIdx].style;\n    //       barOneStyle.height = `${newHeight}px`;\n    //     }, i * 1000);\n    //   }\n    // }\n  }\n\n  handleSelectionSort = () => {\n    const animations = selectionSort(this.state.array, []);\n    for (let i = 0; i < animations.length; i += 1) {\n      const bars = document.getElementsByClassName(styles.barValue);\n      const [barOneIndex, barTwoIndex, changeColor, swap, end] = animations[i];\n      const barOneStyle = bars[barOneIndex].style;\n      const barTwoStyle = bars[barTwoIndex].style;\n      if (!changeColor && !swap && !end) {\n        setTimeout(() => {\n          barOneStyle.backgroundColor = 'green';\n          barTwoStyle.backgroundColor = 'green';\n          if (barTwoIndex > barOneIndex + 1) {\n            bars[barTwoIndex - 1].style.backgroundColor = 'white';\n          }\n        }, SPEED * i);\n      } else if (changeColor && !swap && !end) {\n        setTimeout(() => {\n          barOneStyle.backgroundColor = 'red';\n          barTwoStyle.backgroundColor = 'red';\n        }, SPEED * i);\n        if (barOneIndex !== barTwoIndex) {\n          setTimeout(() => {\n            barOneStyle.backgroundColor = 'white';\n            // barTwoStyle.backgroundColor = 'white';\n          }, SPEED * i + SPEED)\n        }\n      } else if (changeColor && swap && !end) {\n        setTimeout(() => {\n          const temp = barTwoStyle.height;\n          barTwoStyle.height = barOneStyle.height;\n          barOneStyle.height = temp;\n        }, SPEED * i);\n      } else if (end) {\n        setTimeout(() => {\n          barOneStyle.backgroundColor = 'red';\n          barTwoStyle.backgroundColor = 'red';\n        }, SPEED * i);\n      }\n    }\n  }\n\n  handleBubbleSort = () => {\n    const animations = bubbleSort(this.state.array, []);\n    for (let i = 0; i < animations.length; i += 1) {\n      const bars = document.getElementsByClassName(styles.barValue);\n      const [barOneIndex, barTwoIndex, swap, end] = animations[i];\n      const barOneStyle = bars[barOneIndex].style;\n      const barTwoStyle = bars[barTwoIndex].style;\n      if (!swap && !end) {\n        setTimeout(() => {\n          if (bars[barOneIndex - 1]) {\n            bars[barOneIndex - 1].style.backgroundColor = 'white';\n          }\n          barOneStyle.backgroundColor = 'green';\n          barTwoStyle.backgroundColor = 'green';\n        }, SPEED * i);\n      } else if (end) {\n        setTimeout(() => {\n          if (bars[barOneIndex - 1]) {\n            bars[barOneIndex - 1].style.backgroundColor = 'white';\n          }\n          barOneStyle.backgroundColor = 'red';\n        }, SPEED * i);\n      } else {\n        setTimeout(() => {\n          const temp = barTwoStyle.height;\n          barTwoStyle.height = barOneStyle.height;\n          barOneStyle.height = temp;\n        }, SPEED * i);\n      }\n    }\n  }\n\n  render() {\n    const { array } = this.state;\n    return (\n      <div className={styles.visualizerContainer}>\n        <div className={styles.bars}>\n          {\n            array.map((value, index) => (\n              <div\n                className={styles.barValue}\n                key={index}\n                style={{ height: `${value}px`}}\n              >\n              </div>\n            ))\n          }\n        </div>\n        <button onClick={this.handleNew}>New Numbers</button>\n        {/* <button onClick={this.handleMergeSort}>Merge</button> */}\n        <button onClick={this.handleSelectionSort}>Selection</button>\n        <button onClick={this.handleBubbleSort}>Bubble</button>\n      </div>\n    );\n  }\n}\n\nexport default Visualizer;","import React from 'react';\n\nimport Visualizer from './containers/Visualizer/Visualizer';\n// import BarContainer from './BarContainer';\nimport './App.scss';\n\nclass App extends React.Component {\n  // state = {\n  //   numbers: [500, 100, 400, 10, 40, 220, 600],\n  // }\n\n  // start = () => {\n  //   const numbers = [ ...this.state.numbers ];\n    \n  //   let i = 0;\n  //   const times = numbers.length;\n  //   const sort = () => {\n  //     if (i < times) {\n  //       setTimeout(sort, 200);\n  //     }\n  //     i += 1;\n  //   }\n  //   sort();\n  //   for (let i = 0; i < numbers.length; i += 1) {\n  //     let min = numbers[i];\n  //     for (let j = i + 1; j < numbers.length; j += 1) {\n  //       if (numbers[j] < min) {\n  //         min = numbers[j];\n  //         let temp = numbers[i];\n  //         numbers[i] = min;\n  //         numbers[j] = temp;\n  //         continue;\n  //       }\n\n  //     }\n  //   }\n  //   this.setState({\n  //     numbers,\n  //   });\n  // }\n\n  // reset = () => {\n  //   this.setState({\n  //     numbers: [ ...dummy ],\n  //   });\n  // }\n\n  render() {\n    return (\n      <div className=\"App\">\n        <Visualizer></Visualizer>\n      </div>\n    );\n  }\n\n  // render() {\n  //   return (\n  //     <div className=\"App\">\n  //       <header className=\"App-header\">\n  //         <div>hello world</div>\n  //         <BarContainer numbers={this.state.numbers} />\n  //         <button onClick={this.start}>click me</button>\n  //         <button onClick={this.reset}>reset</button>\n  //       </header>\n  //     </div>\n  //   );\n  // }\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}